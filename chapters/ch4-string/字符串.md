# 字符串

## 字典树

### 普通Trie

```cpp
struct Trie {
    int ch[maxn][30];
    bool has[maxn], vis[maxn];
    int cnt;
    void init() {
        memset(ch, 0, sizeof ch);
        memset(has, 0, sizeof has);
        memset(vis, 0, sizeof vis);
        cnt = 1;
    }
    void insert(char *s, int n) {
        int u = 0;
        for (int i = 0; s[i]; i++) {
            int c = s[i] - 'a';
            if (!ch[u][c]) ch[u][c] = ++cnt;
            u = ch[u][c];
        }
        has[u] = 1;
    }
    int query(char *s, int n) {
        int u = 0;
        for (int i = 0; i < n; i++) {
            int c = s[i] - 'a';
            if (!ch[u][c]) return -1;
            u = ch[u][c];
        }
        if (!has[u]) return -1;
        if (!vis[u]) {
            vis[u] = 1;
            return 0;
        } else
            return 1;
    }
};
```

对于 0-1 字典树：

- 找异或最大值:当前位是 1 就走 0，是 0 就走 1,；走不通再走另一个；
- 找与/或的最大值：以与运算为例，如果当前位是 1，那么肯定优先走 1；如果当前位是 0，那么当前位 和 0 或 1 运算的结果都是 0，我们无法确定走哪条支路才是最优解。于是我们可以将两条路合并成一条，把 1 的树自底向上合并到 0 的树

### 压位Trie

```cpp
namespace BITWISE{
    inline int clz(unsigned long long x){return __builtin_clzll(x);}//这个函数是查询开头几个零
    inline int ctz(unsigned long long x){return __builtin_ctzll(x);}//这个函数是查询末尾几个零
} // namespace BITWISE

using namespace BITWISE;

typedef unsigned long long ull;
const int g = 6;
const int mod = (1 << g) - 1;
ull BUFF[1 << 25], *BT = BUFF + sizeof(BUFF) / sizeof(ull);//预先开好内存池
inline ull *alloc(int sz){return BT -= sz;}//动态分配空间
struct Trie{
    int dep;ull *a[5];//动态数组
    Trie(int sz){//初始化
        dep = 1;
        for(;;++ dep){
            int cnt = (sz + (1ull << g * dep) - 1) >> g * dep;//表示这一层有多少个点
            a[dep - 1] = alloc(cnt);
            if(cnt == 1) return ;
        }
        //注意这里层数越小越深，这样方便我们位运算
    }
    inline void ins(int x){
        for (int i = 0;i < dep;++ i){//自下而上遍历的
            ull p = 1ull << (x >> i * g & mod); //判断我们这个 x 在当前这一层要走哪一条边，并且直接左移好方便压位的处理
            if(a[i][x >> (i + 1) * g] & p) return ;//剪枝，上面有就可以弹出了
            a[i][x >> (i + 1) * g] |= p;
        }
    }
    inline void del(int x){
        for (int i = 0;i < dep;++ i)
            if(a[i][x >> (i + 1) * g] &= ~(1ull << (x >> i * g & mod))) return ;//删除一个位置，同样是删完还有就不删了的剪枝
    }
    inline int succ(int x){
        for (int i = 0;i < dep;++ i){
            int cur = (x >> i * g) & mod;ull v = a[i][x >> (i + 1) * g];//当前是哪一条边，由于这里只需要知道是哪一条边所以我们不需要左移
            if(v >> cur > 1){//如果存在前驱，也可以写成 v >> (cur + 1)，后者更好理解但前者似乎更快
                int res = x >> (i + 1) * g << (i + 1) * g;
                res += (ctz(v >> (cur + 1)) + cur + 1) << i * g;//先把这一层的贡献加上，注意是不完整的
                for (int j = i - 1;~j;-- j) res += ctz(a[j][res >> (j + 1) * g]) << j * g;//剩下每一层都是完整的
                return res;//直接返回
            }
        }
        return 0;//否则返回零
    }
    inline int pre(int x){//与上面同理，不赘述
        for (int i = 0;i < dep;++ i){
            int cur = (x >> i * g) & mod;ull v = a[i][x >> (i + 1) * g];
            if(v & ((1ull << cur) - 1)){
                int res = x >> (i + 1) * g << (i + 1) * g;
                res += (mod - clz(v & ((1ull << cur) - 1))) << i * g;
                for (int j = i - 1;~j;-- j) res += (mod - clz(a[j][res >> (j + 1) * g])) << j * g;
                return res;
            }
        }
        return 0;
    }

};
Trie s(1 << 30);

void work(){
    /**
    1.插入 x 数(若已有 x 则不进行此操作);
    2.删除 x 数(若 x 不存在则不进行此操作);
    3.求 x 的前趋(前趋定义为 小于 x,且最大的数,若不存在则答案为 0);
    4.求 x 的后继(后继定义为 大于 x,且最小的数,若不存在则答案为 0);
    **/
    int op, x, ans;

  	if(op == 0) s.ins(x);
    else if(op == 1) s.del(x);
    else if(op == 2) ans = s.pre(x);
    else ans = s.succ(x);
}
```



## Hash

### 字符串Hash

```cpp
#include<bits/stdc++.h>

using namespace std;
typedef unsigned long long ll;

const int N=1e5+5;

struct Hash {
    const int base = 131;           // 13331 19260817 防止哈希冲突
    const ll p = 212370440130137957;// (1ull<<61)-1 {402653189,805306457,1610612741,998244353}
 // 模两个质数的双哈希，建议取一些比较不常见的质数，比如 122420729,163227661,217636919, 1222827239, 998244353 等
    ll Pow[N], h[N];
 
    inline ll mul(ll x, ll y) {
        return (x * y - (ll) ((long double) x / p * y) * p + p) % p;
    }
    inline ll add(ll x, ll y) { return (x += y) >= p ? x - p : x; } 
 
    void init(char *s) {
        int l = strlen(s + 1); 
        Pow[0] = 1; 
        for (int i = 1; i <= l; ++i) Pow[i] = mul(Pow[i - 1], base);
        for (int i = 1; i <= l; ++i) h[i] = add(s[i], mul(h[i - 1], base));
    }
    ll get(int l, int r) { return add(h[r], p - mul(h[l - 1], Pow[r - l + 1])); }
} h;
//=======================双哈希
const basePrime1 = 233;
const basePrime2 = 13331;
// 模两个质数的双哈希，建议取一些比较不常见的质数，比如 122420729,163227661,217636919, 1222827239, 998244353 等
pair<int, int> double_hash(char *s, int n, int mod1, int mod2) {
    int hash1 = 0, hash2 = 0;
    for (int i = 0; i < n; i++)
        hash1 = (1LL * hash * basePrime1 + s[i]) % mod1,
        hash2 = (1LL * hash * basePrime2 + s[i]) % mod2;
    return make_pair(hash1, hash2);
}
```

### 手写Hash + 集合 Set（Set自带Hash）

拉链法也称开散列法（open hashing）。

拉链法是在每个存放数据的地方开一个链表，如果有多个键值索引到同一个地方，只用把他们都放到那个位置的链表里就行了。查询的时候需要把对应位置的链表整个扫一遍，对其中的每个数据比较其键值与查询的键值是否一致。

> 2020 CCPC秦皇岛 J. Jewel Splitting：https://codeforces.com/gym/102769/problem/J（哈希的各种技巧）

```cpp
#include<bits/stdc++.h>

using namespace std;
const int maxn = 310000;

const unsigned long long x = 23333;//131;
const long long mod = 998244353;
unsigned long long H[maxn], xp[maxn];
long long fac[maxn], inv[maxn];
char s[maxn];
int n;
void init() {
	n = strlen(s);
	H[n] = 0;
	for (int i = n - 1; i >= 0; --i)
		H[i] = H[i + 1] * x + s[i];// - 'a' + 1;
	xp[0] = 1;
	for (int i = 1; i <= n; ++i)
		xp[i] = xp[i - 1] * x;
}

inline unsigned long long Hash(int i, int d) {
	return H[i] - H[i + d] * xp[d];
}

//key_t应当为整数类型，且实际值必须非负
template<typename key_t, typename type> struct hash_table {
	static const int maxn = 610000;  	  // 哈希表的大小
	static const int table_size = 800;    // 索引的范围
	int first[table_size], nxt[maxn], sz; // init: memset(first, 0, sizeof(first)), sz = 0
	key_t id[maxn];
	type data[maxn];
	hash_table() {
		init();
	}
	void init(){
		memset(first, 0, sizeof(first));
		sz = 0;
	}
	type& operator[] (key_t key) {
		const int h = key % table_size;
		for (int i = first[h]; i; i = nxt[i])
			if (id[i] == key)
				return data[i];
		int pos = ++sz;
		nxt[pos] = first[h];
		first[h] = pos;
		id[pos] = key;
		return data[pos] = type();
	}
	bool count(key_t key) {
		for (int i = first[key % table_size]; i; i = nxt[i])
			if (id[i] == key)
				return true;
		return false;
	}
	type get(key_t key) { //如果key对应的值不存在，则返回type()。
		for (int i = first[key % table_size]; i; i = nxt[i])
			if (id[i] == key)
				return data[i];
		return type();
	}
};

struct Set {
	hash_table<unsigned long long, int> d;
	// 这个集合的 Hash
	unsigned long long code = 0;
	long long result = 1;// 题目需要
	void init() {
		code = 0;
		result = 1;
		d.init();
	}
	void insert(unsigned long long x) {
		auto val = d[x];
		d[x] += 1;
		result = result * fac[val] % mod * inv[val + 1] % mod; 
		unsigned long long t = val + 37;
		code += x * x * x + 7 * x * x + 3 * x + 7;
	}
	void erase(unsigned long long x) {
		auto val = d[x];
		d[x] -= 1;
		result = result * fac[val] % mod * inv[val - 1] % mod;
		unsigned long long t = val + 37;
		code -= x * x * x + 7 * x * x + 3 * x + 7;
	}
	auto hash() {
		return code;
	}
};
int main() {
    
	fac[0]= inv[1] = 1;
	for (int i = 1; i < maxn; ++i) fac[i] = fac[i - 1] * i % mod;
	for (int i = 2; i < maxn; i++) inv[i] = (long long)inv[mod % i] * (mod - mod / i) % mod;
	
	int T, kase = 0;
	scanf("%d", &T);
	Set S;
	hash_table<unsigned long long, int> vis;
	while (T--) {
		scanf("%s", s);
		init();
		long long ans = 0;
		for (int d = 1; d <= n; d++) {
			S.init();
			vis.init();
			for (int i = 0; i + d <= n; i += d) S.insert(Hash(i, d)); // hash [i, i + d)
			vis[S.hash()]++;
			
			ans += fac[n / d] * S.result % mod;
			int dis = n % d;
			if (dis == 0) continue;
			
			for (int i = n - dis - d; i >= 0; i -= d) {
				S.erase(Hash(i, d));
				S.insert(Hash(i + dis, d));
				if (!vis.count(S.hash())) {
					vis[S.hash()]++;
					ans += fac[n / d] * S.result % mod;
				}
			}
		}
		ans %= mod;
		printf("Case #%d: %lld\n", ++kase, ans);
	}
	return 0;
}

```

### 树Hash

> 给定一棵以点 1 为根的树，你需要输出这棵树中最多能选出多少个互不同构的子树。
>
> 两棵有根树 T1、T2 同构当且仅当他们的大小相等，且存在一个顶点排列 σ 使得在 T1 中 $i$ 是 $j$ 的祖先当且仅当在 T2 中 $σ(i)$ 是 $σ(j)$ 的祖先。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef unsigned long long ull;

mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
ull base = rnd();
const int N = 1e6 + 5;
int n, tot, sz[N];
ull h[N];
vector<int> e[N];

ull H(ull x) {
	return x * x * x * 11451419 + 19260817;
}
ull F(ull x) {
	return
		H(x & ((1ll << 32) - 1)) +
		H(x >> 32);
}
// 注释一种双Hash，需要预处理质数
void dfs(int u, int fa) {
	h[u] = base;
    // f1[u] = 1;
    // f2[u] = 0;
    for (int v : e[u]) {
        if (v == fa) continue;
		dfs(v, u);
		h[u] += F(h[v]);
        // f1[u] += f1[v] * prime[sz[v]];
        // f2[u] += f2[v] * base + sz[v];
    }
    // if (sz[u] == 1) f2[u] = 1;
}
int main() {
	scanf("%d", &n);
	for (int i = 1, u, v; i < n; ++i) {
	    scanf("%d%d", &u, &v);
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dfs(1, 0);
	sort(h + 1, h + 1 + n);
	printf("%d\n", unique(h + 1, h + 1 + n) - h - 1);
	return 0;
}
```



## KMP

字符串 $s$ 的**border**：若 $s$ 的一个子串既是它的前缀又是它的后缀，则这个子串是它的border（一般不包含本身）

字符串 $s$ 的**period**：循环节。用前 $T$ 个字符向后不断复制，能得到 $s$，最后一次可以只复制一部分


> **引理1**：如果有一个border $k$ 长度大于 $s$ 的一半，可以得出得 $s$ 有周期 $|s|−|k|$

> **引理2**：如果 $p,q$ 都为周期，则 $\gcd(p,q)$ 也为周期

> **引理3**：字符串 $s$ 所有不小于 $|s|$ 一半的border构成一个等差数列

> **引理4**：可以把字符串分成 $log|s|$ 段，每一段的border都是一个等差数列

```cpp
#include<iostream>
using namespace std;
const int N=1000010;
int n,m;
char p[N],s[N];
int ne[N];
int main()
{
    cin>>n>>p+1>>m>>s+1;
    // 求ne过程看成两个相同的串匹配
    for(int i=2,j=0;i<=n;i++)
    {
        while(j&&p[i]!=p[j+1]) j=ne[j];
        if(p[i]==p[j+1]) j++;// i结尾能够匹配 1~j 那么ne[i]=j
        ne[i]=j;
    }
    // 当前需要判断是否匹配 p[j+1]?=s[i]
    for(int i=1,j=0;i<=m;i++)
    {
        while(j&&s[i]!=p[j+1]) j=ne[j];
        if(s[i]==p[j+1]) j++;
        if(j==n)
        {
            cout<<i-n<<' ';
            j=ne[j];
        }
    }
    return 0;
}
```

### Border等差数列

一个字符串的所有border可以被我们分成log数量级个等差数列。

在 KMP 匹配中，我们可以利用这个性质快速跳过一串border

具体而言，在一次跳border时，如果发现border长度不小于原串的一半，则接下来的border构成等差数列，直到一半以下（引理3）


可以直接跳到 $(x−\lfloor\frac{\lfloor\frac{x}{2}\rfloor}{d}\rfloor×d)$ 处，即比一半大的第一个位置（整除）

（网上博客直接跳到了 $x\mod d+d$处，经过几道题检验也是对的，但不是很能理解）

一次至少跳一半，保证 $\log$ 次以内可以跳完

> 有 m 组询问，每组询问给定 p, q，求 s 的 p 前缀和 q前缀 的 **最长公共border** 的长度。

```cpp
#include <bits/stdc++.h>

using namespace std;
const int N = 1000010;
int n, m;
char s[N];int ne[N];
int main() {
    cin >> s + 1; n = strlen(s + 1);
    for (int i = 2, j = 0; i <= n; i++) {
        while (j && s[i] != s[j + 1]) j = ne[j];
        if (s[i] == s[j + 1]) j++;
        ne[i] = j;
    }
    int m; cin >> m;
    while (m--) {
        int p, q;
        cin >> p >> q;
        p = ne[p], q = ne[q];
        while (p != q) {
            if (p < q) swap(p, q);

            if (ne[p] > p / 2) {
                int d = p - ne[p];
                if (p % d == q % d)
                    p = q;
                else
                    p = p % d + d;
            } else
                p = ne[p];
        }
        cout << p << '\n';
    }
    return 0;
}
```

### 最小重复字符矩阵

q组询问，每次询问一个矩形的最小重复字符矩阵，行列hash，为了在KMP加速匹配过程。

```cpp
#include <iostream>
using namespace std;
typedef unsigned long long ull;
const int N = 2010;

const ull P = 13331;
int n, q;
char s[N][N];
ull hr[N][N], hc[N][N], p[N];
int ne[N];
// 第 s[l~r][i] 和 s[l~r][j] 是否相等 
bool samc(int i, int j, int l, int r) {
    ull x = hc[i][r] - hc[i][l - 1] * p[r - l + 1];
    ull y = hc[j][r] - hc[j][l - 1] * p[r - l + 1];
    return (x == y);
}
// 第 s[i][l~r] 和 s[j][l~r] 是否相等 
bool samr(int i, int j, int l, int r) {
    ull x = hr[i][r] - hr[i][l - 1] * p[r - l + 1];
    ull y = hr[j][r] - hr[j][l - 1] * p[r - l + 1];
    return (x == y);
}
int main() {
    cin >> n >> q;
    for (int i = 1; i <= n; i++) cin >> s[i] + 1;
    p[0] = 1;
    for (int i = 1; i <= n; i++) p[i] = p[i - 1] * P;

    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            hr[i][j] = hr[i][j - 1] * P + s[i][j];

    for (int j = 1; j <= n; j++)
        for (int i = 1; i <= n; i++)
            hc[j][i] = hc[j][i - 1] * P + s[i][j];

    while (q--) {
        int a, b, c, d;
        cin >> a >> b >> c >> d;

        for (int i = 2, j = 0; i <= d - b + 1; i++) {
            while (j && !samc(i + b - 1, j + b, a, c)) j = ne[j];

            if (samc(i + b - 1, j + b, a, c))
                j++;
            ne[i] = j;
        }

        int ans = d - b + 1 - ne[d - b + 1];

        for (int i = 2, j = 0; i <= c - a + 1; i++) {
            while (j && !samr(i + a - 1, j + a, b, d)) j = ne[j];

            if (samr(i + a - 1, j + a, b, d))
                j++;
            ne[i] = j;
        }
        ans *= c - a + 1 - ne[c - a + 1];
        cout << ans << '\n';
    }

    return 0;
}
```



## Bitset乱搞字符匹配

核心思想：假设文本串为 $s$，则对字符集中的每一个字符 $c$ 开一个大小为 $|s|$ 的 bitset $\text{pos}_c$，记录 $c$ 出现在 $s$ 中的哪些位置。用多个模式串 $t$ 去匹配 $s$，并且求出 $t$ 在 $s$ 中每一次出现的结束位置，那么有这样一个套路：开一个长度为 $|s|$ 的 bitset M 作为答案，一开始每一位都为 1。

>  M 的含义：所有为 1 的位为可能的结束位置。​

对于任意一个匹配的位置 $s_j=t_i$，位置 $j+|t|-i$ $\color{Red}可能$作为完全匹配的结束位置。考虑所有的 $t_i$ 后，将所有限制合起来就可以得到最终的结束位置。

> 冷知识：bitset 有**数值**类型的 `_Find_first()` 和 `_Find_next(x)` 函数（后者如果没有找到下一个位置会返回 bitset 的大小）。这可以非常方便地帮助我们在 $O(\frac n ω+c)$ 的复杂度内找到 bitset 中所有为 1 的位置。

> 题意简述：给出文本串 s，多次询问 $l,r,y$ 求 $y$ 在 $s[l:r]$ 中出现了多少次。带修。$|s|,∑|y|≤10^5$


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
char s[N],t[N];
int n,m,q;
bitset<N> pos[26],ans;
int main()
{
ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);
	cin>>s+1>>q;
	n=strlen(s+1);
	for(int i=1;i<=n;i++) pos[s[i]-'a'][i]=1;

	while(q--)
	{
		int op;cin>>op;
		if(op==1)
		{
			int i;char c;
			cin>>i>>c;
			pos[s[i]-'a'][i]=0;
			s[i]=c;
			pos[s[i]-'a'][i]=1;
		}
		else
		{
			int l,r;cin>>l>>r>>t+1;
			m=strlen(t+1);	
			if(m>r-l+1) {cout<<"0\n";continue;}
			ans.set();ans[0]=1;
			for(int i=1;i<=m;i++) ans&=(pos[t[i]-'a']<<(m-i)); // j+m-i 可能作为答案 bitset 右移
			cout<<(int)(ans>>l+m-1).count()-(ans>>r+1).count()<<'\n'; // 差分求可能的位置
		}
	}
	return 0;
}
```

## Manacher 算法

• $r[i]$: 以 $i$ 为回文中心的回文串半径

• $pre[i]$ 以  $i$ 为起点的回文串数量

• $suf[i]$: 以 $i$ 为终点的回文串数量

> 对于一个字符串 s ，它的本质不同回文子串个数最多只有 |s|个。

```cpp
namespace Manacher {
    int r[maxn << 1], pre[maxn << 1], suf[maxn << 1], l, len;
    char str[maxn << 1];
    // r[i]新串以i为中心的回文半径 r[i]-1对应一个原串回文长度
    int init(char *s) {
        str[0] = '$', str[1] = '#', len = 2, l = strlen(s);
        for (int i = 0; i < l; i++)
            str[len++] = s[i], str[len++] = '#';
        str[len] = 0;
        return len; // 返回构造的字符串长度
    }

    int solve() {
        int ans = -1, id = 0, mx = 0;
        for (int i = 1; i < len; i++) {
            r[i] = (i < mx) ? min(r[2 * id - i], mx - i) : 1;
            while (str[i - r[i]] == str[i + r[i]])
                r[i]++;
            if (mx < i + r[i])
                mx = i + r[i], id = i;
            ans = max(ans, r[i] - 1);
        }
        return ans; // 返回最长回文半径
    }

    void calc() {
        for (int i = l * 2, x; i >= 2; i--)
            x = i / 2, pre[x]++, pre[x - (r[i] / 2)]--;
        for (int i = l; i >= 1; i--)
            pre[i] += pre[i+1];
        for (int i = 2, x; i <= l * 2; i++)
            x = (i + 1) / 2, suf[x]++, suf[x + (r[i] / 2)]--;
        for (int i = 1; i <= l; i++)
            suf[i] += suf[i-1];
    }
 }
```

## **AC** 自动机

在 Trie 树的基础上，为节点增加 fail 指针；当前节点失配的时候，将匹配指针转移到 fail 指针指向的节点。

**建树**

- 根节点指向的所有节点的 $fail$ 指针都指向根节点

- 不存在的节点，$fail$ 指针指向根节点

- 普通节点，字符为 $s$ 的 $fail$ 指针，指向它的父节点的 $fail$ 指针指向节点 $fail[p]$ 沿 $s$ 走到的节点。

**匹配**

- 如果走到了不存在的节点，则将匹配指针移到 fail 指针指向的节点

- 从根节点开始匹配，原理与 Trie 树相同，匹配指针沿着 $p[i]$ 所在的字母向下走

- 如果失配，则沿着 fail 指针移动，若匹配上则继续匹配，否则不断沿着 fail 指针走。

**Fail 指针**

- 每个节点 $s$ 有一个失配指针 $p$ ，所有的 $s$ 和它们的 $p$ 构成的树形结构称为 fail 树。

- fail 树上每个节点所代表的字符串，是其所有子树所代表的字符串的后缀 ⇒ 一个节点所有祖先，代表的字符串都是这个节点代表的字符串的后缀，如下图所示。

- 重要性质：每个节点的 fail 指针，都指向当前节点代表的字符串的最长后缀（如果存在）。

**Fail 指针的用法**：

- 统计每个模式串 p 在文本串 t 当中出现的次数：将 t 在 AC 自动机的上匹配同时建立 fail 树，当经过某个节点时，对答案的贡献为：这个节点所有祖先的权值之和。利用树上差分将经过的所有节点计数 + 1。

- 一个模式串 $p_i$ 在其它模式串中出现的次数统计：如果 $p_i$ 在其它的模式串中出现，那么其它模式串的链上一定有一个节点的 fail 指针指向该节点，直接统计该节点在 fail 树上的子节点个数即可。

```cpp
namespace ACAM { 
    struct Trie {
        int ch[26],fail,cnt;
    }trans[N];
    int ins(char *s) {
        int p=0;
        for(int i=0;s[i];i++) {
            int c=s[i]-'a';
            if(!trans[p].ch[c]) trans[p].ch[c]=++cnt;
            p=trans[p].ch[c];
        }
        return p;
    }
    void getfail() {
        queue<int> q;
        for(int i=0;i<26;i++)
        	if(trans[0].ch[i]) q.push(trans[0].ch[i]);
        	
        while(q.size()) {
            int u=q.front();q.pop();
            for(int i=0;i<26;i++) {
                int &ch=trans[u].ch[i];
                if(ch) // add(trans[ch].fail,ch);// 构建失配树 fail指针向自己连边
                    trans[ch].fail=trans[trans[u].fail].ch[i],q.push(ch);
                else// 如果没有儿子 那么将fail的儿子作为儿子
                    ch=trans[trans[u].fail].ch[i];  
            }
        }
    }
    // t在AC自动机中跑一遍
    void find (char *t) { 
    	int n = strlen(t + 1);
    	for (int i = 1, p = 0; i <= n; i++) {
        	int c = t[i] - 'a';
        	p = trans[p].ch[c];
        	// ......
    	}
	}
}
```

字符集较大的情况：可以用map来维护 `tran[N][26]` ，也可以用可持久花数组维护map<int,int> trans[N]

```cpp
vector<pair<int,int>> trie[N]; // trie树的结构，邻接表vector
map<int,int> trans[N];
int fail[N];
void getfail()
{
    queue<int>q;
    for(auto it:trie[0]) {
        int u=0,v=it.second,to=it.first;
        // u-(to)-> v
        trans[u][to]=v;
        fail[v]=u;
        q.push(v);
    }
    while(!q.empty()) {
        int u=q.front(); q.pop();
        trans[u]=trans[fail[u]];//先把fail的trans 复制移过来
        
        for(auto it:trie[u]) {
            int v=it.second,to=it.first;
            trans[u][to]=v; // 然后修改
            fail[v]=trans[fail[u]][to]; 
            q.push(v);
        }
    }
}
// 可持久花数组维护map<int,int> trans[N]
struct Node {
    int l,r,v;
}trans[N*40];// 1~n trans[u][1~n] = v
int rt,cnt;
```



> 给定 $n$ 个字符串 $s_{1 \dots n}$。, $q$ 次询问 $s_{l \dots r}$ 在 $s_k$ 中出现了多少次。$n,q,\sum_{i=1}^n |s_i| \le 10^5$。

出现多串一定要考虑一下根号分治。

- 对于 $|s_k| < B$ 的，可以在 ac 自动机上暴力跑，差分一下用扫描线求一下，需要一个 $O(\sqrt N) - O(1)$ 的数据结构。

- 对于 $|s_k| \geq B$ 的，这样的串不会有很多种，对于每种，把该串在ac自动机上的路径加1，然后计算子树和就可获得每个点在该串的出现次数。

总复杂度 $O(n\sqrt n)$

```cpp
// 1. s[k]在 s[l~r]出现多少次
// 2. s[l~r]在 s[k] 中共出现多少次

// 如何理解 s[k] 在 s[r] 中出现的次数

// 1. 修改：s[r]的子串是根到 pos[r] 的链 + 1
//    查询：pos[k]子树即可               差分 + 扫描线

// 2. 修改：将 pos[k] 的子树打上标记 
//    查询：根到 pos[r] 的链上有多少标记 差分 + 扫描线 

#include <bits/stdc++.h>
using namespace std;


using LL = long long;
using PII = pair<int, int>;

const  int N = 1000005;
struct ACAM{
  int ch[N][26], cnt = 1, q[N], fa[N], head[N], ne[N];
  int ins(int p, int x) {
    if (!ch[p][x]) ch[p][x] = ++cnt;
    return ch[p][x];
  }
  void build() {
    int l, r;
    q[l = r = 1] = 1;
    while (l <= r) {
      int x = q[l++];
      if (x > 1 && !fa[x]) fa[x] = 1;
      for (int i = 0; i < 26; i++) {
        int &y = ch[x][i], z = ch[fa[x]][i];
        if (y) {
          q[++r] = y, fa[y] = z;
        } else {
          y = z;
        }
      }
    }

    for (int i = 2; i <= r; i++) {
      int x = fa[q[i]];
      assert(x);
      ne[i] = head[x], head[x] = i;
    }
    dfs(1);
  }

  int in[N], out[N], dfn;
  void dfs(int x) {
    in[x] = dfn++;
    for (int i = head[x]; i; i = ne[i]) {
      dfs(q[i]);
    }
    out[x] = dfn;
  }

  int val[N];
  void clear() {
    memset(val, 0, cnt + 1 << 2);
  }
  void cal() {
    for (int i = cnt; i; i--) {
      val[fa[q[i]]] += val[q[i]];
    }
  }
} ac;

template <class T>
struct DS {
  T s0[N], s1[(N >> 8) + 1];
  void add(int l, int r, const T &x) {
    while (l & 255 && l < r) s0[l++] += x;
    while (l + 256 <= r) s1[l >> 8] += x, l += 256;
    while (l < r) s0[l++] += x;
  }
  T ask(int p) {
    return s0[p] + s1[p >> 8];
  }
};

DS<int> ds;

int n, m, pos[N];
string s[N];
int main() {
  
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  cin >> n >> m;
  for (int i = 1; i <= n; i++) {
    cin >> s[i];
    int p = 1;
    for (char c : s[i]) {
      p = ac.ins(p, c - 'a');
    }
    pos[i] = p;
  }

  vector<LL> ans(m);
  vector<array<int, 4>> q0, q1;
  for (int i = 0, l, r, k; i < m; i++) {
    cin >> l >> r >> k;
    if (s[k].size() < 350) {
      q0.push_back({r, 1, k, i});
      q0.push_back({l - 1, -1, k, i});
    } else {
      q1.push_back({k, l, r, i});
    }
  }

  sort(q0.begin(), q0.end());
  sort(q1.begin(), q1.end());

  ac.build();
  
  for (int i = 0, j = 1; i < q0.size(); i++) {
    while (j <= q0[i][0]) {
      int x = pos[j++];
      ds.add(ac.in[x], ac.out[x], 1);
    }
    int p = 1;
    LL res = 0;
    for (char c : s[q0[i][2]]) {
      p = ac.ch[p][c - 'a'];
      res += ds.ask(ac.in[p]);
    }
    ans[q0[i][3]] += q0[i][1] * res;
  }

  vector<LL> sum(n + 1);
  for (int i = 0; i < q1.size(); i++) {
    auto &[k, l, r, id] = q1[i];
    if (!i || q1[i - 1][0] != k) {
      ac.clear();
      int p = 1;
      for (char c : s[k]) {
        p = ac.ch[p][c - 'a'];
        ac.val[p]++;
      }
      
      ac.cal();     // 子树求和
      // ac.val[pos[j]] 是 s[j] 在 s[k] 出现的次数
      for (int j = 1; j <= n; j++) {
        sum[j] = sum[j - 1] + ac.val[pos[j]];
      }
    }
    ans[id] = sum[r] - sum[l - 1];
  }

  for (auto z : ans) cout << z << "\n";
  return 0;
}
```



## 后缀数组

### 模板

```cpp
namespace Suffix_Array {
    // sa[i]: 排名是i位的是第几个后缀
    // rk[i]: 第i个后缀的排名是多少
    // height[i]: sa[i]与sa[i-1]
    const int N=1000010;
    char s[N];
    int rk[N],sa[N],c[N],height[N];
    int x[N],y[N];
    int n,m;
    void rsort()// x[i] 第一关键字 y[i] 第二关键字 基数排序
    {
        for(int i=1;i<=m;i++) c[i]=0;
        for(int i=1;i<=n;i++) c[x[i]]++;
        for(int i=1;i<=m;i++) c[i]+=c[i-1];
        for(int i=n;i;i--) sa[c[x[y[i]]]--]=y[i];
    }
    void build_sa()
    {
        n=strlen(s+1);
        m=256; // 值域 最开始是ascii码的范围 
        for(int i=1;i<=n;i++) x[i]=s[i],y[i]=i;
        rsort();
        for(int k=1;k<=n;k<<=1)
        {
            int p=0;
            for(int i=n-k+1;i<=n;i++) y[++p]=i;// 第二关键字为空字符排在最前面
            for(int i=1;i<=n;i++) if(sa[i]>k) y[++p]=sa[i]-k;
            rsort();swap(x,y);
    
            x[sa[1]]=1,p=1;
            for(int i=2;i<=n;i++)
                x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&&y[sa[i]+k]==y[sa[i-1]+k]?p:++p);
            if(p==n) break;
            m=p;
        }
    }
    void get_height()
    {
        for(int i=1;i<=n;i++) rk[sa[i]]=i;
        // 求height
        for(int i=1,j=0;i<=n;i++)
        {
            if(j) --j;
            while(s[i+j]==s[sa[rk[i]-1]+j]) j++;
            height[rk[i]]=j;
        }
    }
    // 求lcp 有时需要找到本质不同第k大最早出现的位置
    // 首先二分能找到第k大，然后再次二分找到[sa[l]....sa[r]] 取最小值就是最早出现的位置
    int mnht[N][22];
	int mnsa[N][22];
	int lg[N];
	void init() {
	    lg[0]=-1;
	    for(int i=1;i<=n;i++) lg[i]=lg[i>>1]+1;
	    for(int i=1;i<=n;i++) mnht[i][0]=height[i],mnsa[i][0]=sa[i];
	    for(int j=1;j<=lg[n];j++)
	        for(int i=1;i+(1<<j)-1<=n;i++)
	            mnht[i][j]=min(mnht[i][j-1],mnht[i+(1<<j-1)][j-1]),\
	            mnsa[i][j]=min(mnsa[i][j-1],mnsa[i+(1<<j-1)][j-1]);
	}
	int MIN(int a[][22],int l,int r)
	{
	    int k=lg[r-l+1];
	    return min(a[l][k],a[r-(1<<k)+1][k]);
	}
	// 询问 suffix(a) 和 suffix(b) 的最长公共前缀
	int lcp(int a,int b) 
	{
	    a=rk[a],b=rk[b];
	    if(a>b) swap(a,b);
	    a++;
	    int k=lg[b-a+1];
	    return min(mnht[a][k],mnht[b-(1<<k)+1][k]);
	}
	
}using namespace Suffix_Array;
```

### SA 应用

**寻找最小的循环移动位置 **

> [# P4051 [JSOI2007]字符加密](https://www.luogu.com.cn/problem/P4051)：给出一个字符串S，将该字符串循环移位后的n个字符串按照字典序排列，输出排序后的每个尾字符。

将字符串 S 复制一份变成 SS 就转化成了后缀排序问题。

**在字符串中找子串**

> 任务是在线地在主串 S 中寻找模式串 P。在线的意思是，我们已经预先知道主串 S，但是当且仅当询问时才知道模式串 P。

构造出 S 的后缀数组，若 P 在 S 的子串出现，必定是 S 的后缀的前缀，因为已经将 S 的后缀按照字典序排序了，既可以二分 `sa[mid]` 数组，比较 S 排名是`mid`的后缀和 P 的字典序大小，比较复杂度为 $O(|P|)$，每次查找的复杂度为 $O(|P|\log |S|)$。

注意，如果该子串在 S 中出现了多次，每次出现都是在 sa 数组中相邻的。因此出现次数可以通过再次二分找到，输出每次出现的位置也很轻松。

**两子串最长公共前缀**
$$
\text{lcp}(sa[i],sa[j])=\min\{\text{height}[i+1,\dots,j]\}
$$
所以求后缀$S_{i\to n}$ 和 $S_{j\to n}$的最长公共前缀 $\text{lcp}(i,j)$

$$\text{lcp}(i,j)=\min\{\text{height}[rk[i]+1,\dots,rk[j]\}$$


如果 height 一直大于某个数，前这么多位就一直没变过；反之，由于后缀已经排好序了，不可能变了之后变回来（height一旦减小，就会有别的字符替代，而且由于字典序的问题是不可逆的）。有了这个定理，求两子串最长公共前缀就转化为了 [RMQ 问题](https://oi-wiki.org/topic/rmq/)

**比较一个字符串的两个子串的大小关系**

> 假设需要比较的是 $A=S[a...b]$ 和  $B=S[c...d]$ 的大小关系。

若$\text{lcp}(S[a...n],S[c...n])>\min(|A|,|B|)$，则$A<B \Leftrightarrow |A| <|B|$ 
否则$A<B \Leftrightarrow \text{rk}[a] <\text{rk}[c]$ 

**不同子串的数目**

$\color{Red}子串就是后缀的前缀$，所以可以枚举每个后缀，计算前缀总数，再减掉重复。

“前缀总数”其实就是子串个数，为$n(n+1)/2$。

如果按后缀排序的顺序枚举后缀，每次新增的子串就是除了与上一个后缀的 LCP 剩下的前缀。只有这些前缀是新增的，因为 LCP 部分在枚举上一个前缀时计算过了。

**出现至少 K 次的子串的最大长度**

出现至少 $k$ 次意味着后缀排序后有至少连续 $k$ 个后缀的 LCP 是这个子串。
所以，求出每相邻 $k-1$ 个 height 的最小值，再求这些最小值的最大值就是答案。

**至少出现两次且不重叠的最长子串**

若可重叠，答案就是$\max\{height[i]\}$

可以$\color{Red}二分目标串的长度$ $|S|$，将 $\text{height}$ 数组划分成若干个连续 LCP 大于等于$|S|$ 的段，利用 RMQ 对每个段求其中出现的数中最大和最小的下标，若这两个下标的距离满足条件（不重叠），则一定有长度为 $|S|$ 的字符串不重叠地出现了两次。

**结合并查集**

某些题目求解时要求你将后缀数组划分成若干个连续 LCP 长度大于等于某一值的段，亦即将 $\text{height}$ 数组划分成若干个连续最小值大于等于某一值的段并统计每一段的答案。

如果有多次询问，我们可以将询问离线。观察到当给定值单调递减的时候，满足条件的区间个数总是越来越少，而新区间都是两个或多个原区间相连所得，且新区间中不包含在原区间内的部分的 $\text{height}$ 值都为减少到的这个值。我们只需要维护一个并查集，每次合并相邻的两个区间，并维护统计信息即可。

**结合单调栈**

> [AHOI2013](https://www.luogu.com.cn/problem/P4248)差异
> 给定一个长度为 $n$ 的字符串 $S$，令 $T_i$ 表示它从第 $i$ 个字符开始的后缀。求
> $$\displaystyle \sum_{1\leqslant i<j\leqslant n}\text{len}(T_i)+\text{len}(T_j)-2\times\text{lcp}(T_i,T_j)$$
> 其中，$\text{len}(a)$ 表示字符串 $a$ 的长度，$\text{lcp}(a,b)$ 表示字符串 $a$ 和字符串 $b$ 的最长公共前缀。


被加数的前两项很好处理，为 $(n-1)n(n+1)/2$ （每个后缀都出现了 $n-1$ 次，后缀总长是 $n(n+1)/2$），关键是最后一项，即后缀的两两 LCP。

我们知道  $\text{lcp}(i,j)=k$ 等价于 $\text{lcp}(i,j)=\min\{\text{height}[i+1,...,j]\}=k$。

考虑 Height 数组的贡献：Height 数组中 $[2, n]$ 内的每一个区间都给答案贡献区间最小值。

我们换一个角度来思考：如果设$\min\{\text{height}[i+1,...,j]\}=\text{height}[k]$，那么我们认为$\text{height}[k]$ 产生了一个贡献，所以我们可以从每一个 $\text{height}[k]$ 产生了多少贡献的角度来思考。

$\color{Red}套路：每个区间的区间最小值之和，使用单调栈解决。$
注意单调栈，寻找时左闭右开 $[ \dots)$

```cpp
 // L[i]表示左侧第一个<=height[i]的位置
    q[tt=0]=1;
    for(int i=2;i<=n;i++)
    {
        while(tt&&height[q[tt]]>height[i]) tt--;
        L[i]=q[tt];
        q[++tt]=i;
    }
    // R[i] 表示右侧第一个<height[i]的位置
    q[tt=0]=n+1;
    for(int i=n;i>=2;i--) 
    {   
        while(tt&&height[q[tt]]>=height[i]) tt--;
        R[i]=q[tt];
        q[++tt]=i;
    }   
    for(int i=2;i<=n;i++) (R[i]-i)*(i-L[i])*height[i];
```
**求本质不同第 $k$ 大子串**

首先第 $k$ 大可以二分，对后缀排序后，先二分定位第 $k$ 大属于哪一个后缀（后缀的前缀是子串）

按照经典的，把重复的子串算在排名靠前的后缀中，排名为 $i$ 的后缀对总子串（不同）的贡献是 $n-sa[i]+1-\text{height}[i]$，然后预处理一个前缀和就可以二分第k大 “大致” 属于哪一个后缀，甚至可以直接确定子串。

不过本题要求输出子串最早出现的位置（左右端点确定一个子串）。

上述求的该串的**开始位置**不一定是**最小**的，所以顺着sa数组要往后找是否还有更小的答案。（因为排名i,i+1的子串有lcp）

```cpp
int l=j,r=n;
while(l<r)
{
    int mid=l+r+1>>1;
    if(MIN(mnht,j+1,mid)>=q[i].l) l=mid;
    else r=mid-1;
}
j=MIN(mnsa,j,r);
```

**重复次数最多的连续子串**

> [Repeats：](https://vjudge.net/problem/SPOJ-REPEATS) 给一个串，一段（连续）子串称为 $(k,l)$ 重复的，如果它满足由一个长度为 $l$ 的重复了 $k$ 次组成。求最大的 $k$

枚举答案子串长度 $L$，在 $\frac{N} {L}$ 个关键点中，答案子串必须覆盖相邻的2个点。枚举相邻的关键点 $j$ 和 $j+L$，看它们往前往后各能匹配到多长。将反串接在原串后一起求SA，用lcp信息更新 ans：

![Pasted image 20221203140054](D:\Program Files\Note\Other\Pasted image 20221203140054.png)

具体的枚举长度 $L=2$ 时，上图紫色和青色是关键的的位置，考虑两个青色的（相邻）关键点，红色部分是往后扩展的长度，橘色部分是往前扩展的长度（正反串的 $\text{lcp}(j, j+L)$ ）然后加起来就是循环长度。

```cpp
ans = max(ans, (lcp(j, j+i)+lcp(N-j+1,N-(j+i)+1)+i-1)/i);
```

**其他**

- 最长回文子串：将整个字符串反过来接在原字符的后面，中间用一个特殊的字符隔开，求新字

  符串某两个后缀的最长公共前缀即可。

- A,B 的最长公共子串：首先把 B连接到 A 的末尾，两者中间用一个没出现过的字符，然后求新串的后缀数组、height 数组等。然后遍历 height 数组，当 $suffix(sa[i])$和 $suffix(sa[i-1])$ 不是同一个字符串中的两个后缀时，最大的 $height[i]$ 就满足条件。判断 $suffix(sa[i])$和 $suffix(sa[i-1])$ 是否为同一个字符串中的两个后缀，只需判断下标的位置即可。

- 给定 *n* 个字符串，求出现在不小于 *k* 个字符串中的最长子串：将 *n* 个字符串连接，中间用没出

  现过的字符隔开，求后缀数组。然后二分长度 *l* 并利用 *height* 数组分组，判断每组的后缀是否

  出现在不小于 *k* 个原串中。

- 给定 *n* 个字符串，求出现或反转后出现在每个字符串中的最长子串：将每个字符串反转后的结

  果也拼到总串中，求后缀数组。判断的时候, 要看是否有一组后缀在每个原来的字符串或反转后

  的字符串中出现.

## 后缀自动机

**名词解释**

- endpos(s)：子串s所有出现的位置（尾字母下标）集合。SAM中的每个状态都一一对应一个endpos的等价类。
- SAM 中的一个状态包含的子串都具有相同的 endpos，它们$\color{Red}都互为后缀$（两个子串的endpos相同，那么短串为长串的后缀）。其中一个状态指的是从起点开始到这个点的所有路径组成的子串的集合。
- $len$ 表示从当前 $endpos$ 可向前延伸的长度最大值。设当前构造的 $SAM$ 已得到的子串为 $s$， 从当前字符向前数 $[0, len]$ 个字符得到的新子串 $t$，$t$ 一定只作为 $s$ 的后缀出现。

---

**性质**

- 字符串 $s$ 的一个后缀自动机包含关于字符串 $s$ 的所有子串的信息。任意从初始状态 $s_0$ 开始的路径，如果我们将转移路径上的标号写下来，都会形成 $s$ 的一个 子串 。反之每个 $s$ 的子串对应从初始状态 $s_0$  开始的某条路径。
- $parent$ 树中的每个节点的终点集合，等于其子树内所有终点节点对应的终点集合的并集。可以用线段树合并维护endpos集合
- $parent$ 树中，如果节点 $a$ 是 $b$ 的祖先，则节点 $a$ 对应的字符串是节点 $b$ 对应的字符串的后缀。
- 构成的 $parent$ 树存在一些与树相关的性质，如 $S_{1...p}$ 和 $S_{1...q}$ 的最长公共后缀对应的是 $p, q$ 对应节点间的 LCA 的字符串。
- 除了初始状态（节点 $1$）以外，每个状态 $i$ 对应的字串数量是 $len(i) - len(link(i))$，因此计算时可以自上而下计算。

```cpp
namespace SuffixAutomaton {
    const int maxn = 200050;
    const int MAXLOG = 25;
    // 需要维护 right 集合时，加上以下动态开点线段树的代码
    struct Node {
        int val, l, r;
    } t[maxn * 40];
    int cnt;        // 权值线段树节点个数

    void pushup(int u) {
        t[u].val = t[t[u].l].val + t[t[u].r].val;
    }
    void update(int &u, int l, int r, int pos) {
        if (!u)
            u = ++cnt, t[u].l = t[u].r = t[u].val = 0;
        if (l == r) {
            t[u].val++;
            return;
        }
        int mid = (l + r) >> 1;
        if (pos <= mid)
            update(t[u].l, l, mid, pos);
        else
            update(t[u].r, mid + 1, r, pos);
        pushup(u);
    }
    int merge(int x, int y) {
        if (!x || !y)
            return x + y;
        int o = ++cnt;
        t[o].l = merge(t[x].l, t[y].l);
        t[o].r = merge(t[x].r, t[y].r);
        pushup(o);
        return o;
    }

    int query(int u, int l, int r, int L, int R) {
        if (!u) return 0;
        if (L <= l && r <= R) return t[u].val;
        int mid = l+r>>1;
        int v = 0;
        if (L < =mid) v += query(t[u].l, l, mid, L, R);
        if (R > mid) v += query(t[u].r, mid+1, r, L, R);
        return v;
    }
    /* 后缀自动机 */
    struct State {
        int len, link, ch[26];
        State(int _len = 0, int _link = 0): len(_len), link(_link) {
            memset(ch, 0, sizeof ch);
        }
    } st[maxn << 1];    // 最多有 2n-1 个节点，开两倍空间

    // tot: 状态个数，last: 上一次插入的字符对应状态，sum：当前产生子串个数，n 字符串长度
    // sa c 基数排序数组, endpos[i] 表示 i 状态所代表的 endpos 集合线段树的树根
    int last, tot;
    int n, sum;
    int endpos[maxn << 1], sa[maxn << 1], c[maxn << 1], pos[maxn << 1];
    int f[maxn << 1][MAXLOG];
    int ans[maxn << 1];
    int extend(int c, int idx) {
        int p = last;
        int np = last = ++ tot;
        
        st[np] = State(st[p].len + 1);
        ans[np] = 1;

        endpos[np] = 0; 				// idx是endpos集合中最靠左的firstpos
        update(endpos[np], 1, n, idx);  // 更新当前点的 endpos，注意权值线段树值域范围

        for (; p && !st[p].ch[c]; p=st[p].link) st[p].ch[c] = np;
        
        if (!p) st[np].link = 1;
        else {
            int q = st[p].ch[c];
            if (st[q].len == st[p].len + 1)
                st[np].link = q;
            else {
                int clone = ++tot;
                st[clone] = State(st[p].len + 1, st[q].link);
                memcpy(st[clone].ch, st[q].ch, sizeof st[q].ch);
                
                endpos[clone] = 0;              // 为克隆节点新建 endpos，但不建树
                for (;p && st[p].ch[c] == q; p = st[p].link) st[p].ch[c] = clone;
                st[q].link = st[np].link = clone;
            }
        }
        sum += st[np].link ? st[np].len : st[np].len - st[st[np].link].len;   // 字串个数
        return sum;          
    }
    
    // 基于基数排序的拓扑排序，保证状态间的拓扑关系，即子状态在后，父状态在前
    // 后缀自动机更新信息时，需要先更新子状态 s，再更新父状态 link[s]
    void toposort() {
        memset(sa, 0, sizeof sa);
        memset(c, 0, sizeof c);
        for (int i = 1; i <= tot; i++)
            c[st[i].len]++;            // 排序的关键字是 len
        for (int i = 1; i <= tot; i++)
            c[i] += c[i-1];
        for (int i = 1; i <= tot; i++)
            sa[c[st[i].len]--] = i;
    }
    // 建立后缀自动机
    void build(char s[]) {
        n = strlen(s + 1);
        for (int i = 1; i <= n; i++) {
            extend(s[i] - 'a', i);
            pos[i] = last;
        }
        // 预处理倍增表
        for (int i = 1; i <= tot; i++) f[i][0] = st[i].link;
        for (int j = 1; j < MAXLOG; j++)
            for (int i = 1; i <= tot; i++)
                f[i][j] = f[f[i][j-1]][j-1];

        toposort();
        // 如果需要维护 right 集合：从子节点开始，合并 endpos 集合
        for (int i = tot; i > 1; i--) {
            int u = sa[i];
            if (st[u].link)
                endpos[st[u].link] = merge(endpos[st[u].link], endpos[u]);
        }
    }
    // 询问子串 s[l,r] 在子串 s[L,R] 中出现的次数。
    int solve(int l, int r, int L, int R) {
        // 首先从 endpos 为 r 的节点开始，倍增找到与目标串一样长的点
        int u = pos[r], nplen = r - l + 1;
        for (int i = MAXLOG - 1; i >= 0; i--)
            if (st[f[u][i]].len >= nplen)
                u = f[u][i];
        return query(endpos[u], 1, n, L + r - l, R);
    }
    void init() {
        sum = 0, tot = 0,
        st[last = ++tot] = State(0, 0);
        memset(t, 0, sizeof t);     // 清空权值线段树
    }
} using namespace SuffixAutomaton;
```

按照 len 拓扑排序，能够递推求出记录每个节点的最左边出现的位置endpos和最右边出现的位置endpos。

### 应用

**不同子串的数目**

SAM，其实就是统计所有状态包含的子串总数，也就是 $\sum_i \text{maxlen}[i]-\text{minlen}[i]+1$，而实际上知道$\text{minlen}[i]=\text{maxlen}[fa[i]]+1$。

每个 S 的子串都相当于自动机中的以S0为起点的一些路径。因此不同子串的个数等于自动机中**以 S0 为起点的不同路径的条数**。考虑到 SAM 为有向无环图，不同路径的条数可以通过动态规划计算。具体的：即令 $d_u$ 为从状态 u 开始的路径数量（或称之不同子串数目），对于节点u，u如果通过字母c转移到了后继v，有方程：（$\color{Red}加1是只考虑字母c的这一条路径$）

$$
d_u=1+\sum_{(u,v,c)\in\text{DAWG}} d_v
$$
可以通过dfs一下根节点向下记忆化搜索实现，也可以**逆拓扑序**往回更新实现。

$\color{Green}其实通过此我们有两种角度理解SAM上的点也就是状态$

- endpos：每个状态维护一些endpos相同的子串，维护的子串数量$\text{maxlen}[i]-\text{minlen}[i]+1$
- 路径：从起点S0到该状态的一条路径唯一对映一个子串，并且路径数量等于维护的子串数量。

**所有不同子串的总长度**

类似的令$f_u$ 为从状态 u 开始的不同子串的总长度，对于v状态的所有子串都可以在前缀加上字符c，一共多出$d_v$，+1是只考虑字母c的这一条路径。（Oiwiki上没+1是因为 $d_u$ 包括空字串）

$$
f_u=1+\sum_{(u,v,c)\in\text{DAWG}} (d_v+f_v)
$$
**任意子串的数目**

首先考虑一个子串出现的次数，不难发现就是它 endpos 集合的大小。所以我们当前需要计算的就是 $∀st|endpos(st)|$ 的大小。如果我们每次构建时候维护这个的话，每次需要按着fa边跳到 s 更新所有状态的 endpos，然后**判断子串属于哪个状态**就能得出次数（回忆：每个状态 endpos 集合相同，endpos集合维护的是相同子串尾出现的位置）

由于fa边构成一颗树，前面讲过了我们每次是暴力把路径上的所有点权值 +1 。我们就能转化成 DAG　每一个点对于它能走的路径上的所有点 +1 ，这个直接考虑在 DAG 图上进行拓扑 dp 就行了。

但$\color{Red}注意 \text{clone} 的节点是不能对它到 S 的路径上有单独贡献的$，因为它的贡献会在它的本体上计算一遍。

**字典序第 K 大子串**

字典序第 K 大的子串对应于 SAM 中字典序第 K 大的路径，因此在计算每个状态的路径数后。我们可以很容易地从 SAM 的根开始找到第 K 大的路径。

如果不同位置的相同子串算作多个，那么还需要提前求出任意子串的数目（建立后缀树，令前缀的cnt=1，dfs更新一遍），否则只需要让记每个状态的 cnt=1

**第一次出现的位置**

> 给定一个文本串 S，多组查询。每次查询字符串 P 在字符串 S 中第一次出现的位置（ 的开头位置）。

我们构造一个后缀自动机。我们对 SAM 中的所有状态预处理位置 $\text{firstpos}$ 。即，对每个状态 u 我们想要找到第一次出现这个状态的末端的位置 $\text{firstpos}[u]$。换句话说，我们希望先找到每个集合 $\text{endpos}$ 中的最小的元素。

当我们创建新状态 np 时，我们令：

$$
\text{firstpos}(np)=\text{len}(np)
$$
$$
\text{firstpos}(nq=\text{clone})=\text{len}(q)
$$

**最短的没有出现的字符串**

>给定一个字符串 S 和一个特定的字符集，我们要找一个长度最短的没有在 S 中出现过的字符串。

在SAM上做dp，设 $\text{dp}[i]$表示到点 $i$ 时需要添加的最短长度的字符满足题意。如果这个点有不是S中字符的出边，则 $\text{dp}[i]=1$（添加一个未出现的字符）否则，不光要添加一个字符还需要向后继续寻找
$$
\text{dp}[i]=1+\min\{\text{dp}_{(i,j,c)\in\text{SAM}}[j]\}
$$
答案就是$\text{dp}[s0]$（起点）

**两个串的最长公共子串**

第一个串建SAM，然后一个一个串处理。在处理每一个串的时候记录当前节点的最大匹配长度，并且记录最大长度的最小值，就是所有串的匹配长度。处理串时能在自动机上走就走，否则跳fa，类似KMP和AC自动机。

```cpp
int p=1,l=0;
for(int j=0;t[j];j++)
{
	int c=t[j]-'a';
	while ( p>1 && !sam[p].ch[c]) p = sam[p].fa,l = sam[p].len;
	if (sam[p].ch[c]) p = sam[p].ch[c], l++;
	len[p] = max(len[p], l);
}

```

**求子串 $[l, r]$ 在子串 $[L, R]$ 的出现次数**

实际上是求子串 $s[l,r]$ 的 endpos 集合中在 $[L+r-l,R]$ 出现的次数，也就是需要维护 endpos 集合，对于一个SAM状态 endpos 集合 应该是所有子树 endpos 集合的并集 + “本身的”（如果改该状态对于是一个前缀）。

**区间 $[l, r]$ 本质不同子串个数**

考虑把本质相同的子串看作同一种颜色。「静态区间不同颜色种类数」的经典问题的加强版！

插入位置 $i$ 时应该在$\color{Red}加入所有以$ $i$ $\color{Red}结尾的子串的贡献$。子串是有长度的，但我们只需维护左端点即可。那么「在线段树中把当前位置 +1」可以直接一次区间修改来完成，而把「上一个相同元素的位置 −1」目前来看不太好做，因为我们还不知道每个子串上一次出现的位置。

为了解决这个问题，我们对原串建立后缀自动机。

以 $i$ 结尾的子串就是前缀 $i$ 对应的节点在 $\text{parent}$ 树上的所有祖先节点。由同一个状态表示的子串，它们「上一次出现的位置」的右端点是相同的，而左端点是连续的一段。

可以通过暴力跳 $\text{parent}$ 树上祖先并同时区间修改（增删贡献）来达到目的。同时还需要把这条链上的节点都染成 $i$ 颜色，表示把这些子串最后一次出现的位置修改为 $i$。更具体的：

$\text{parent}$ 树上如果该节点之前被染成 $r$ 颜色，说明子串$[r-maxlen+1\to r,   r]$ 都计算过贡献，如果本次需要将其染成 $i$ 颜色 $i > r$，那么说明 $r, i$ 都是该状态的 $\text{endpos}$ 集合，并且子串 $[r-maxlen+1\to r,   r]$ 和 $[i-maxlen+1\to i,   i]$ 是本质相同的子串！

离线下来扫描区间右端点然后询问左端点即可。

注意：后缀自动机的状态维护：①相同结尾的连续子串 ② endpos 集合相同的子串

发现颜色相同的节点的节点会连成一段，我们可以将它们一起处理。由于只有「将某一点到根节点的颜色染成一种没有出现过的颜色」这一种操作，所有需要处理的链上的总颜色数实际上是 $O(n\log n)$ 的。原因是染色操作其实对应着 LCT 的 $\text{Access}$ 操作，可以套用其复杂度证明方法。所以在实现时我们也可以直接使用 LCT 来维护，因为一条实链上的颜色一定都是相同的，直接模拟 $\text{Access}$ 的过程即可。

### LCT维护Parent树

```cpp
// P6292-区间本质不同子串个数 https://www.luogu.com.cn/problem/P6292

#include<bits/stdc++.h>

using namespace std;
using ll=long long;

const int N=200005;
struct SAM
{
    int ch[26],fa,len;
}sam[N];
int tot=1,last=1;
int extend(int c)
{   
    int p=last;
    int np=last=++tot;
    sam[np].len=sam[p].len+1;
    for(;p&&!sam[p].ch[c];p=sam[p].fa) sam[p].ch[c]=np;

    if(!p) sam[np].fa=1;
    else
    {
        int q=sam[p].ch[c];
        if(sam[q].len==sam[p].len+1) sam[np].fa=q;
        else
        {
            int nq=++tot;sam[nq]=sam[q];
            sam[nq].len=sam[p].len+1;
            sam[q].fa=sam[np].fa=nq;
            for (;p&&sam[p].ch[c]==q;p=sam[p].fa) sam[p].ch[c]=nq;
        }
    } 
    return last;
}

const int maxn = 200005;
namespace Fenwick{ //区间加 区间询问
    ll c0[maxn],c1[maxn];
    void add(int k,int v)
    {
        ll i=k*v;
        while(k<=maxn)
        {
            c0[k]+=v;
            c1[k]+=i;
            k+=k&-k;
        }
    }
    void add(int l,int r,int v){add(l,v);add(r+1,-v);}
    ll qry(int k)
    {
        ll v=0;
        ll k0=k+1,k1=-1;
        while(k)
        {
            v+=k0*c0[k]+k1*c1[k];
            k-=k&-k;
        }
        return v;
    }
    ll qry(int l,int r){return qry(r)-qry(l-1);}

}
//using namespace Fenwick;

//若要修改一个点的点权，应当先将其 splay 到根，然后修改，最后还要调用 pushup 维护。
namespace lct {
    int ch[maxn][2], fa[maxn], stk[maxn], rev[maxn];

    int co[maxn],tag[maxn];
    int val[maxn],len[maxn];

    void init() { //初始化 link-cut-tree
        memset(ch, 0, sizeof(ch));
        memset(fa, 0, sizeof(fa));
        memset(rev, 0, sizeof(rev));
        memset(co, 0, sizeof(co));
        memset(tag, 0, sizeof(tag));
        memset(val,0,sizeof (val));
        memset(len,0,sizeof (len));
        val[0]=0x3f3f3f3f;

    }
    inline bool son(int x) {
        return ch[fa[x]][1] == x;
    }
    inline bool isroot(int x) {
        return ch[fa[x]][1] != x && ch[fa[x]][0] != x;
    }
    inline void reverse(int x) { //给结点 x 打上反转标记
        swap(ch[x][1], ch[x][0]);
        rev[x] ^= 1; 
    }
    inline void cover(int x,int color)
    {
    	co[x]=tag[x]=color;
    }
    inline void pushup(int x) { 
        val[x]=min({val[ch[x][1]],val[ch[x][0]],len[x]});
    }
    inline void pushdown(int x) {
        if (rev[x]) {
            reverse(ch[x][0]);
            reverse(ch[x][1]);
            rev[x] = 0;
        }
        if(tag[x]) {
        	cover(ch[x][0],tag[x]);
        	cover(ch[x][1],tag[x]);
        	tag[x]=0;
        }
    }
    void rotate(int x) {
        int y = fa[x], z = fa[y], c = son(x);
        if (!isroot(y))
            ch[z][son(y)] = x;
        fa[x] = z;
        ch[y][c] = ch[x][!c];
        fa[ch[y][c]] = y;
        ch[x][!c] = y;
        fa[y] = x;
        pushup(y);
    }
    void splay(int x) { // 将x设置为spaly的根节点
        int top = 0;
        stk[++top] = x;
        for (int i = x; !isroot(i); i = fa[i])
            stk[++top] = fa[i];
        while (top)
            pushdown(stk[top--]);
        for (int y = fa[x]; !isroot(x); rotate(x), y = fa[x]) if (!isroot(y))
            son(x) ^ son(y) ? rotate(x) : rotate(y);
        pushup(x);
    }
    void access(int x) { // 建立从根到 x 的路径
        for (int y = 0; x; y = x, x = fa[x]) {
            splay(x);
            ch[x][1] = y;
            pushup(x);
            if(co[x]){
                Fenwick::add(co[x]-sam[x].len+1,co[x]-val[x]+1 ,-1);
                //Fenwick::add(co[x]-sam[x].len+1,co[x]-sam[fa[x]].len ,-1);
            }
        }
    }
}
using namespace lct;

int n,m;
char s[N];
vector<pair<int,int>> q[N];
int pos[N];
ll ans[N];
int main()
{
    cin>>s+1;
    n=strlen(s+1);
    cin>>m;
    for(int i=1;i<=m;i++)
    {
        int l,r;
        cin>>l>>r;
        q[r].push_back({l,i});
    }
    for(int i=1;i<=n;i++) pos[i]=extend(s[i]-'a'); 
    init();
    for(int i=1;i<=tot;i++) 
    {
        fa[i]=sam[i].fa;
        val[i]=len[i]=sam[sam[i].fa].len+1;
    }
    for(int r=1;r<=n;r++)
    {
        access(pos[r]);
        splay(pos[r]);
        cover(pos[r],r);
        Fenwick::add(r-sam[pos[r]].len+1,r,1);
        for(auto [l,id]:q[r])  ans[id]=Fenwick::qry(l,r);
        
    }
    for(int i=1;i<=m;i++) cout<<ans[i]<<'\n';

    return 0;
}
```

## 最小表示法

字符串 S 的最小表示为与 S 循环同构（循环左移）的所有字符串中字典序最小的字符串

```cpp
int MinimumRepresentation(char *s, int n) {  
    int i = 0, j = 1, k = 0, t;  
    while(i < n && j < n && k < n) {  
        // s[(i + k) % n] == s[(j + k) % n]
        t = s[(i + k) >= n ? i + k - n : i + k] \
          - s[(j + k) >= n ? j + k - n : j + k];  
        if(!t) k++;  
        else{  
            if(t > 0) 
                i = i + k + 1;  
            else 
                j = j + k + 1;  
            if(i == j) ++ j;  
            k = 0;  
        }  
    }  
    return (i < j ? i : j);  
}  
```

## **Lyndon** 分解

**Lyndon 串的定义**：对于字符串 $s$，如果 $s$ 的字典序严格小于 $s$ 的所有后缀的字典序，我们称 $s$ 是简单串，或者 Lyndon 串 。

**Lyndon 分解**： $s$ 的 Lyndon 分解记为 $s = w_1w_2...w_k$，其中所有的 $w_i$ 为简单串，且字典序非单调递增，即 $w_{i-1} \ge w_i$。

```cpp
namespace Lyndon {
    vector<string> duval(string s) {
        int n = s.size(), i = 0;
        vector<string> res;
        while (i < n) {
            int j = i + 1, k = i;
            while (j < n && s[k] <= s[j]) {
                if (s[k] < s[j])
                    k = i;
                else
                    k++;
                j++;
            }
            while (i <= k)
                res.emplace_back(s.substr(i, j - k)), i += j - k;
        }
        return res;
    }
    // 使用 Lyndon 分解求最小表示
    string minimum_representation(string s) {
        s += s;
        int n = s.size();
        int i = 0, ans = 0;
        while (i < n / 2) {
            ans = i;
            int j = i + 1, k = i;
            while (j < n && s[k] <= s[j]) {
                if (s[k] < s[j])
                    k = i;
                else
                    k++;
                j++;
            }
            while (i <= k) i += j - k;
        }
        return s.substr(ans, n / 2);
    }    
}
```

